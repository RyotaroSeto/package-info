# package-info

## パッケージの構成要素としては、基本的に以下
- プログラム
- ドキュメント
- メタデータ
  - そのパッケージに関する情報が記述されたデータ

## ライブラリ, モジュールとの違い
- ライブラリ
  - 再利用可能なコードの集まり。特定の目的に対しての機能を提供する。ライブラリにはパッケージも、モジュールも含まれる
- モジュール
  - プログラムの一部分であり、通常はファイルとして実装される
  - モジュールは関数、クラス、変数、定数などを含むことができる
- ライブラリの中にパッケージがあり、パッケージの中にモジュールがあり、その中に関数やクラスがある

## バージョン管理
- セマンティックバージョニング
  - X.Y.Z（メジャー.マイナー.パッチ）というバージョン形式ルール
 
## 依存解決アルゴリズム
パッケージ管理システムは複雑怪奇な依存関係を一体どのように解決、解消しているのか

### トポロジカルソート
- 一般的なソートアルゴリズム。有向グラフを入力として使用して、各ノードがそのノードが指すノードの前に表示されるようにノードを並べ替える
  - このアルゴリズムはLinuxOSのパッケージ管理システムとして知られるaptやJavaのプロジェクト管理ツールであるApatchMavenで使用されている
  - トポロジカルソートでは、循環した依存関係を解決できない。

### PubGrub
- Dart言語のパッケージ管理システムであるPubの依存関係解決アルゴリズム
- 効率的かつ、複数のパッケージ間における非互換性を明らかにできるという点で優れており、先述したPub(Dart)以外にもSwiftPM(Swift)や、gel-rb(Ruby)、poetry(Python)といった様々なパッケージ管理システムで使用
- トポロジカルソートと同様に、PubGrubにおいてもパッケージの依存関係を解決するためにグラフ理論に基づいたアルゴリズムを使用
- このアルゴリズムは依存関係のグラフを構築し、各パッケージが他のパッケージにどのように依存しているかを考慮して解決を行う
- PubGrubには依存関係グラフ上の競合を回避しつつ依存関係を解決する強力な機能がある
- コアループ
  - PubGrubが依存関係を解決するための中核となる部分
  - 伝播フェーズと決定フェーズという2つのフェーズを交互に繰り返しながら、競合が起きることのないパッケージバージョンのリストを組み上げていく
    - 初めの伝播フェーズでは、選択したパッケージバージョンのリストと、それらに対応する非互換性セットを組み合わせて、それぞれの条件が満たされるようなバージョンを探索
      - 例えば、menu 1.4.0を選択している場合、非互換性{menu ≥ 1.1.0, not dropdown ≥ 2.0.0}から、dropdown ≥ 2.0.0が必要だという条件が導かれます
      - dropdown ≥ 2.0.0が導かれたら、このtermと非互換性{dropdown ≥ 2.0.0、not icons ≥ 2.0.0}を組み合わせてicons ≥ 2.0.0を導き出すことができる
      - このようにtermが次々と導かれていき、最終的に導出できるものがなくなるまで続く
      - 可能な限り導出をしたうえで、まだ条件が満たせていない依存関係のパッケージがある場合、次の決定フェーズに移る
        - ここでは、条件を満たすことのできるバージョンを見つける作業が行われますが、基本的には最新のバージョンを選ぶことが多い
      - すべてのパッケージの依存関係が解決されると、プロジェクトの実行が可能。しかし、実際にはそう簡単に事が運ぶこともなく、特定のパッケージ間でなんらかの競合が起こってしまうことがほとんどなため、衝突解決フェーズが必要
- 衝突解決
  - 伝播フェーズの過程で、定義済みの非互換性に抵触してしまう導出がなされることがある
    - 例えば、特定のパッケージからicons ≥ 2.0.0が導き出されてしまったとき、rootがもつ非互換性{root any, not icons < 2.0.0}と衝突する。
    - これを解決するため、PubGrubは衝突解決フェーズに移行
  - このフェーズでは、PubGrubは以前に選択されたパッケージバージョンに戻り、衝突の原因となったバージョンとは別のバージョンを検討
  - これによって、PubGrubは衝突の根本原因を特定し、それを非互換性として新たに記録
